//
//  StyleKit.swift
//  PaintCodeKony
//
//  Created by Fernando Fernandes on 09/03/17.
//  Copyright Â© 2017 backslash-f. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class StyleKit : NSObject {

    //// Cache

    private struct Cache {
        static let green: UIColor = UIColor(red: 0.153, green: 0.608, blue: 0.220, alpha: 1.000)
        static let background: UIColor = UIColor(red: 0.933, green: 0.933, blue: 0.933, alpha: 1.000)
        static let white: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
    }

    //// Colors

    public dynamic class var green: UIColor { return Cache.green }
    public dynamic class var background: UIColor { return Cache.background }
    public dynamic class var white: UIColor { return Cache.white }

    //// Drawing Methods

    public dynamic class func drawGoal(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 132, height: 176), resizing: ResizingBehavior = .aspectFit, goalProgress: CGFloat = 1) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 132, height: 176), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 132, y: resizedFrame.height / 176)



        //// Variable Declarations
        let goalCompleted = goalProgress == 1 ? true : false
        let goalPercentageVisible = goalProgress == 0 ? false : true
        let goalPercentNumber: CGFloat = goalProgress * 100
        let goalPercentText = "\(Int(round(goalPercentNumber)))" + "%"
        let goalResultAngle: CGFloat = -1 * goalProgress * 279

        //// GoalGroup
        //// CircleBackgroundBezier Drawing
        let circleBackgroundBezierPath = UIBezierPath(ovalIn: CGRect(x: 7, y: 41.75, width: 118, height: 117))
        StyleKit.background.setStroke()
        circleBackgroundBezierPath.lineWidth = 10
        circleBackgroundBezierPath.stroke()


        if (goalPercentageVisible) {
            //// CircleProgressStroke Drawing
            let circleProgressStrokeRect = CGRect(x: 7, y: 41.75, width: 118, height: 117)
            let circleProgressStrokePath = UIBezierPath()
            circleProgressStrokePath.addArc(withCenter: CGPoint.zero, radius: circleProgressStrokeRect.width / 2, startAngle: 133 * CGFloat.pi/180, endAngle: -(goalResultAngle + 227) * CGFloat.pi/180, clockwise: true)

            var circleProgressStrokeTransform = CGAffineTransform(translationX: circleProgressStrokeRect.midX, y: circleProgressStrokeRect.midY)
            circleProgressStrokeTransform = circleProgressStrokeTransform.scaledBy(x: 1, y: circleProgressStrokeRect.height / circleProgressStrokeRect.width)
            circleProgressStrokePath.apply(circleProgressStrokeTransform)

            StyleKit.green.setStroke()
            circleProgressStrokePath.lineWidth = 11
            circleProgressStrokePath.lineCapStyle = .round
            circleProgressStrokePath.stroke()
        }


        //// BaseBezier Drawing
        let baseBezierPath = UIBezierPath()
        baseBezierPath.move(to: CGPoint(x: 29.01, y: 138.28))
        baseBezierPath.addLine(to: CGPoint(x: 110.36, y: 138.28))
        baseBezierPath.addCurve(to: CGPoint(x: 117.09, y: 139.47), controlPoint1: CGPoint(x: 109.43, y: 138.28), controlPoint2: CGPoint(x: 113.46, y: 138.28))
        baseBezierPath.addLine(to: CGPoint(x: 117.79, y: 139.64))
        baseBezierPath.addCurve(to: CGPoint(x: 129, y: 155.6), controlPoint1: CGPoint(x: 124.52, y: 142.09), controlPoint2: CGPoint(x: 129, y: 148.46))
        baseBezierPath.addCurve(to: CGPoint(x: 129, y: 156.51), controlPoint1: CGPoint(x: 129, y: 156.51), controlPoint2: CGPoint(x: 129, y: 156.51))
        baseBezierPath.addLine(to: CGPoint(x: 129, y: 156.51))
        baseBezierPath.addLine(to: CGPoint(x: 129, y: 156.51))
        baseBezierPath.addLine(to: CGPoint(x: 129, y: 157.43))
        baseBezierPath.addCurve(to: CGPoint(x: 117.79, y: 173.38), controlPoint1: CGPoint(x: 129, y: 164.57), controlPoint2: CGPoint(x: 124.52, y: 170.94))
        baseBezierPath.addCurve(to: CGPoint(x: 101.38, y: 174.75), controlPoint1: CGPoint(x: 113.46, y: 174.75), controlPoint2: CGPoint(x: 109.43, y: 174.75))
        baseBezierPath.addLine(to: CGPoint(x: 23.64, y: 174.75))
        baseBezierPath.addCurve(to: CGPoint(x: 16.91, y: 173.56), controlPoint1: CGPoint(x: 24.57, y: 174.75), controlPoint2: CGPoint(x: 20.54, y: 174.75))
        baseBezierPath.addLine(to: CGPoint(x: 16.21, y: 173.38))
        baseBezierPath.addCurve(to: CGPoint(x: 5, y: 157.43), controlPoint1: CGPoint(x: 9.48, y: 170.94), controlPoint2: CGPoint(x: 5, y: 164.57))
        baseBezierPath.addCurve(to: CGPoint(x: 5, y: 156.51), controlPoint1: CGPoint(x: 5, y: 156.51), controlPoint2: CGPoint(x: 5, y: 156.51))
        baseBezierPath.addLine(to: CGPoint(x: 5, y: 156.51))
        baseBezierPath.addLine(to: CGPoint(x: 5, y: 156.51))
        baseBezierPath.addLine(to: CGPoint(x: 5, y: 155.6))
        baseBezierPath.addCurve(to: CGPoint(x: 16.21, y: 139.64), controlPoint1: CGPoint(x: 5, y: 148.46), controlPoint2: CGPoint(x: 9.48, y: 142.09))
        baseBezierPath.addCurve(to: CGPoint(x: 32.62, y: 138.28), controlPoint1: CGPoint(x: 20.54, y: 138.28), controlPoint2: CGPoint(x: 24.57, y: 138.28))
        baseBezierPath.addLine(to: CGPoint(x: 23.64, y: 138.28))
        baseBezierPath.addLine(to: CGPoint(x: 29.01, y: 138.28))
        baseBezierPath.close()
        StyleKit.green.setFill()
        baseBezierPath.fill()


        //// GoalPercentageText Drawing
        let goalPercentageTextRect = CGRect(x: 5, y: 138.75, width: 124, height: 36)
        let goalPercentageTextStyle = NSMutableParagraphStyle()
        goalPercentageTextStyle.alignment = .center
        let goalPercentageTextFontAttributes = [NSFontAttributeName: UIFont.systemFont(ofSize: 20), NSForegroundColorAttributeName: StyleKit.white, NSParagraphStyleAttributeName: goalPercentageTextStyle]

        let goalPercentageTextTextHeight: CGFloat = goalPercentText.boundingRect(with: CGSize(width: goalPercentageTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: goalPercentageTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: goalPercentageTextRect)
        goalPercentText.draw(in: CGRect(x: goalPercentageTextRect.minX, y: goalPercentageTextRect.minY + (goalPercentageTextRect.height - goalPercentageTextTextHeight) / 2, width: goalPercentageTextRect.width, height: goalPercentageTextTextHeight), withAttributes: goalPercentageTextFontAttributes)
        context.restoreGState()


        //// GoalIconFlightBezier Drawing
        context.saveGState()
        context.translateBy(x: 42.8, y: 77.31)
        context.scaleBy(x: 1.1, y: 1.1)

        let goalIconFlightBezierPath = UIBezierPath()
        goalIconFlightBezierPath.move(to: CGPoint(x: 39.61, y: 36.1))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 42.51, y: 33.32))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 31.43, y: 16.17))
        goalIconFlightBezierPath.addCurve(to: CGPoint(x: 40.58, y: 1.85), controlPoint1: CGPoint(x: 41.07, y: 6.84), controlPoint2: CGPoint(x: 42.15, y: 3.36))
        goalIconFlightBezierPath.addCurve(to: CGPoint(x: 25.64, y: 10.62), controlPoint1: CGPoint(x: 39.01, y: 0.35), controlPoint2: CGPoint(x: 35.37, y: 1.38))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 7.73, y: 0))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 4.83, y: 2.78))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 19.45, y: 16.78))
        goalIconFlightBezierPath.addCurve(to: CGPoint(x: 7.46, y: 30.4), controlPoint1: CGPoint(x: 14.91, y: 21.49), controlPoint2: CGPoint(x: 10.46, y: 26.52))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 1.66, y: 28.03))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 0, y: 29.62))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 4.77, y: 34.19))
        goalIconFlightBezierPath.addCurve(to: CGPoint(x: 3.86, y: 37.03), controlPoint1: CGPoint(x: 3.87, y: 35.67), controlPoint2: CGPoint(x: 3.5, y: 36.68))
        goalIconFlightBezierPath.addCurve(to: CGPoint(x: 6.82, y: 36.16), controlPoint1: CGPoint(x: 4.23, y: 37.37), controlPoint2: CGPoint(x: 5.28, y: 37.02))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 11.59, y: 40.73))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 13.25, y: 39.14))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 10.78, y: 33.58))
        goalIconFlightBezierPath.addCurve(to: CGPoint(x: 25, y: 22.1), controlPoint1: CGPoint(x: 14.84, y: 30.71), controlPoint2: CGPoint(x: 20.08, y: 26.45))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 39.61, y: 36.1))
        goalIconFlightBezierPath.close()
        goalIconFlightBezierPath.usesEvenOddFillRule = true
        StyleKit.green.setFill()
        goalIconFlightBezierPath.fill()

        context.restoreGState()


        if (goalCompleted) {
            //// StarsGroup
            //// Star3Bezier Drawing
            let star3BezierPath = UIBezierPath()
            star3BezierPath.move(to: CGPoint(x: 96.5, y: 10.88))
            star3BezierPath.addLine(to: CGPoint(x: 99.55, y: 16.76))
            star3BezierPath.addLine(to: CGPoint(x: 106.37, y: 17.7))
            star3BezierPath.addLine(to: CGPoint(x: 101.43, y: 22.28))
            star3BezierPath.addLine(to: CGPoint(x: 102.6, y: 28.74))
            star3BezierPath.addLine(to: CGPoint(x: 96.5, y: 25.69))
            star3BezierPath.addLine(to: CGPoint(x: 90.4, y: 28.74))
            star3BezierPath.addLine(to: CGPoint(x: 91.57, y: 22.28))
            star3BezierPath.addLine(to: CGPoint(x: 86.63, y: 17.7))
            star3BezierPath.addLine(to: CGPoint(x: 93.45, y: 16.76))
            star3BezierPath.close()
            StyleKit.green.setFill()
            star3BezierPath.fill()


            //// Star2Bezier Drawing
            let star2BezierPath = UIBezierPath()
            star2BezierPath.move(to: CGPoint(x: 66, y: 1))
            star2BezierPath.addLine(to: CGPoint(x: 70.04, y: 9.19))
            star2BezierPath.addLine(to: CGPoint(x: 79.08, y: 10.5))
            star2BezierPath.addLine(to: CGPoint(x: 72.54, y: 16.87))
            star2BezierPath.addLine(to: CGPoint(x: 74.08, y: 25.87))
            star2BezierPath.addLine(to: CGPoint(x: 66, y: 21.62))
            star2BezierPath.addLine(to: CGPoint(x: 57.92, y: 25.87))
            star2BezierPath.addLine(to: CGPoint(x: 59.46, y: 16.87))
            star2BezierPath.addLine(to: CGPoint(x: 52.92, y: 10.5))
            star2BezierPath.addLine(to: CGPoint(x: 61.96, y: 9.19))
            star2BezierPath.close()
            StyleKit.green.setFill()
            star2BezierPath.fill()


            //// Star1Bezier Drawing
            let star1BezierPath = UIBezierPath()
            star1BezierPath.move(to: CGPoint(x: 35.5, y: 10.88))
            star1BezierPath.addLine(to: CGPoint(x: 38.55, y: 16.76))
            star1BezierPath.addLine(to: CGPoint(x: 45.37, y: 17.7))
            star1BezierPath.addLine(to: CGPoint(x: 40.43, y: 22.28))
            star1BezierPath.addLine(to: CGPoint(x: 41.6, y: 28.74))
            star1BezierPath.addLine(to: CGPoint(x: 35.5, y: 25.69))
            star1BezierPath.addLine(to: CGPoint(x: 29.4, y: 28.74))
            star1BezierPath.addLine(to: CGPoint(x: 30.57, y: 22.28))
            star1BezierPath.addLine(to: CGPoint(x: 25.63, y: 17.7))
            star1BezierPath.addLine(to: CGPoint(x: 32.45, y: 16.76))
            star1BezierPath.close()
            StyleKit.green.setFill()
            star1BezierPath.fill()


        }
        
        context.restoreGState()

    }

    public dynamic class func drawResizableGoal(frame: CGRect = CGRect(x: 1, y: 1, width: 130, height: 174), resizableGoalProgress: CGFloat = 0) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Symbol Drawing
        let symbolRect = CGRect(x: frame.minX + 1, y: frame.minY + 1, width: fastFloor((frame.width - 1) * 0.99225 + 0.5), height: fastFloor((frame.height - 1) * 0.99422 + 0.5))
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        StyleKit.drawGoal(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, goalProgress: resizableGoalProgress)
        context.restoreGState()
    }

    //// Generated Images

    public dynamic class func imageOfGoal(goalProgress: CGFloat = 1) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 132, height: 176), false, 0)
            StyleKit.drawGoal(goalProgress: goalProgress)

        let imageOfGoal = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfGoal
    }

    public dynamic class func imageOfResizableGoal(imageSize: CGSize = CGSize(width: 130, height: 174), resizableGoalProgress: CGFloat = 0) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            StyleKit.drawResizableGoal(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), resizableGoalProgress: resizableGoalProgress)

        let imageOfResizableGoal = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfResizableGoal
    }




    @objc(StyleKitResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
