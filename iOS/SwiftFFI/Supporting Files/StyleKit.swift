//
//  StyleKit.swift
//  PaintCodeKony
//
//  Created by Fernando Fernandes on 3/7/17.
//  Copyright Â© 2017 backslash-f. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class StyleKit : NSObject {

    //// Cache

    private struct Cache {
        static let green: UIColor = UIColor(red: 0.153, green: 0.608, blue: 0.220, alpha: 1.000)
        static let background: UIColor = UIColor(red: 0.933, green: 0.933, blue: 0.933, alpha: 1.000)
        static let white: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
    }

    //// Colors

    public dynamic class var green: UIColor { return Cache.green }
    public dynamic class var background: UIColor { return Cache.background }
    public dynamic class var white: UIColor { return Cache.white }

    //// Drawing Methods

    public dynamic class func drawGoal(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 68, height: 88), resizing: ResizingBehavior = .aspectFit, goalProgress: CGFloat = 1) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 68, height: 88), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 68, y: resizedFrame.height / 88)



        //// Variable Declarations
        let goalCompleted = goalProgress == 1 ? true : false
        let goalPercentageVisible = goalProgress == 0 ? false : true
        let goalPercentNumber: CGFloat = goalProgress * 100
        let goalPercentText = "\(Int(round(goalPercentNumber)))" + "%"
        let goalResultAngle: CGFloat = -1 * goalProgress * 279

        //// GoalGroup
        //// CircleBackgroundBezier Drawing
        let circleBackgroundBezierPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 21, width: 58, height: 58))
        StyleKit.background.setStroke()
        circleBackgroundBezierPath.lineWidth = 7
        circleBackgroundBezierPath.stroke()


        if (goalPercentageVisible) {
            //// CircleProgressStroke Drawing
            let circleProgressStrokeRect = CGRect(x: 5, y: 21, width: 58, height: 58)
            let circleProgressStrokePath = UIBezierPath()
            circleProgressStrokePath.addArc(withCenter: CGPoint(x: circleProgressStrokeRect.midX, y: circleProgressStrokeRect.midY), radius: circleProgressStrokeRect.width / 2, startAngle: 133 * CGFloat.pi/180, endAngle: -(goalResultAngle + 227) * CGFloat.pi/180, clockwise: true)

            StyleKit.green.setStroke()
            circleProgressStrokePath.lineWidth = 7
            circleProgressStrokePath.lineCapStyle = .round
            circleProgressStrokePath.stroke()
        }


        //// BaseBezier Drawing
        let baseBezierPath = UIBezierPath()
        baseBezierPath.move(to: CGPoint(x: 15.81, y: 69))
        baseBezierPath.addLine(to: CGPoint(x: 55.83, y: 69))
        baseBezierPath.addCurve(to: CGPoint(x: 59.14, y: 69.59), controlPoint1: CGPoint(x: 55.37, y: 69), controlPoint2: CGPoint(x: 57.35, y: 69))
        baseBezierPath.addLine(to: CGPoint(x: 59.49, y: 69.67))
        baseBezierPath.addCurve(to: CGPoint(x: 65, y: 77.55), controlPoint1: CGPoint(x: 62.8, y: 70.88), controlPoint2: CGPoint(x: 65, y: 74.03))
        baseBezierPath.addCurve(to: CGPoint(x: 65, y: 78), controlPoint1: CGPoint(x: 65, y: 78), controlPoint2: CGPoint(x: 65, y: 78))
        baseBezierPath.addLine(to: CGPoint(x: 65, y: 78))
        baseBezierPath.addLine(to: CGPoint(x: 65, y: 78))
        baseBezierPath.addLine(to: CGPoint(x: 65, y: 78.45))
        baseBezierPath.addCurve(to: CGPoint(x: 59.49, y: 86.33), controlPoint1: CGPoint(x: 65, y: 81.97), controlPoint2: CGPoint(x: 62.8, y: 85.12))
        baseBezierPath.addCurve(to: CGPoint(x: 51.41, y: 87), controlPoint1: CGPoint(x: 57.35, y: 87), controlPoint2: CGPoint(x: 55.37, y: 87))
        baseBezierPath.addLine(to: CGPoint(x: 13.17, y: 87))
        baseBezierPath.addCurve(to: CGPoint(x: 9.86, y: 86.41), controlPoint1: CGPoint(x: 13.63, y: 87), controlPoint2: CGPoint(x: 11.65, y: 87))
        baseBezierPath.addLine(to: CGPoint(x: 9.51, y: 86.33))
        baseBezierPath.addCurve(to: CGPoint(x: 4, y: 78.45), controlPoint1: CGPoint(x: 6.2, y: 85.12), controlPoint2: CGPoint(x: 4, y: 81.97))
        baseBezierPath.addCurve(to: CGPoint(x: 4, y: 78), controlPoint1: CGPoint(x: 4, y: 78), controlPoint2: CGPoint(x: 4, y: 78))
        baseBezierPath.addLine(to: CGPoint(x: 4, y: 78))
        baseBezierPath.addLine(to: CGPoint(x: 4, y: 78))
        baseBezierPath.addLine(to: CGPoint(x: 4, y: 77.55))
        baseBezierPath.addCurve(to: CGPoint(x: 9.51, y: 69.67), controlPoint1: CGPoint(x: 4, y: 74.03), controlPoint2: CGPoint(x: 6.2, y: 70.88))
        baseBezierPath.addCurve(to: CGPoint(x: 17.59, y: 69), controlPoint1: CGPoint(x: 11.65, y: 69), controlPoint2: CGPoint(x: 13.63, y: 69))
        baseBezierPath.addLine(to: CGPoint(x: 13.17, y: 69))
        baseBezierPath.addLine(to: CGPoint(x: 15.81, y: 69))
        baseBezierPath.close()
        StyleKit.green.setFill()
        baseBezierPath.fill()


        //// GoalPercentageText Drawing
        let goalPercentageTextRect = CGRect(x: 6, y: 73, width: 58, height: 10)
        let goalPercentageTextStyle = NSMutableParagraphStyle()
        goalPercentageTextStyle.alignment = .center
        let goalPercentageTextFontAttributes = [NSFontAttributeName: UIFont.systemFont(ofSize: UIFont.smallSystemFontSize), NSForegroundColorAttributeName: StyleKit.white, NSParagraphStyleAttributeName: goalPercentageTextStyle]

        let goalPercentageTextTextHeight: CGFloat = goalPercentText.boundingRect(with: CGSize(width: goalPercentageTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: goalPercentageTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: goalPercentageTextRect)
        goalPercentText.draw(in: CGRect(x: goalPercentageTextRect.minX, y: goalPercentageTextRect.minY + (goalPercentageTextRect.height - goalPercentageTextTextHeight) / 2, width: goalPercentageTextRect.width, height: goalPercentageTextTextHeight), withAttributes: goalPercentageTextFontAttributes)
        context.restoreGState()


        //// GoalIconFlightBezier Drawing
        let goalIconFlightBezierPath = UIBezierPath()
        goalIconFlightBezierPath.move(to: CGPoint(x: 42.57, y: 57.72))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 44, y: 56.34))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 38.55, y: 47.88))
        goalIconFlightBezierPath.addCurve(to: CGPoint(x: 43.05, y: 40.81), controlPoint1: CGPoint(x: 43.29, y: 43.27), controlPoint2: CGPoint(x: 43.82, y: 41.56))
        goalIconFlightBezierPath.addCurve(to: CGPoint(x: 35.7, y: 45.14), controlPoint1: CGPoint(x: 42.28, y: 40.07), controlPoint2: CGPoint(x: 40.49, y: 40.58))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 26.89, y: 39.9))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 25.46, y: 41.27))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 32.65, y: 48.18))
        goalIconFlightBezierPath.addCurve(to: CGPoint(x: 26.76, y: 54.9), controlPoint1: CGPoint(x: 30.42, y: 50.51), controlPoint2: CGPoint(x: 28.23, y: 52.99))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 23.9, y: 53.73))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 23.09, y: 54.52))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 25.44, y: 56.77))
        goalIconFlightBezierPath.addCurve(to: CGPoint(x: 24.99, y: 58.17), controlPoint1: CGPoint(x: 24.99, y: 57.5), controlPoint2: CGPoint(x: 24.81, y: 58))
        goalIconFlightBezierPath.addCurve(to: CGPoint(x: 26.44, y: 57.74), controlPoint1: CGPoint(x: 25.17, y: 58.34), controlPoint2: CGPoint(x: 25.69, y: 58.17))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 28.79, y: 60))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 29.61, y: 59.22))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 28.39, y: 56.47))
        goalIconFlightBezierPath.addCurve(to: CGPoint(x: 35.38, y: 50.8), controlPoint1: CGPoint(x: 30.39, y: 55.06), controlPoint2: CGPoint(x: 32.96, y: 52.95))
        goalIconFlightBezierPath.addLine(to: CGPoint(x: 42.57, y: 57.72))
        goalIconFlightBezierPath.close()
        goalIconFlightBezierPath.usesEvenOddFillRule = true
        StyleKit.green.setFill()
        goalIconFlightBezierPath.fill()


        if (goalCompleted) {
            //// StarsGroup
            //// Star3Bezier Drawing
            let star3BezierPath = UIBezierPath()
            star3BezierPath.move(to: CGPoint(x: 49, y: 6.12))
            star3BezierPath.addLine(to: CGPoint(x: 50.43, y: 9.03))
            star3BezierPath.addLine(to: CGPoint(x: 53.64, y: 9.49))
            star3BezierPath.addLine(to: CGPoint(x: 51.32, y: 11.75))
            star3BezierPath.addLine(to: CGPoint(x: 51.87, y: 14.94))
            star3BezierPath.addLine(to: CGPoint(x: 49, y: 13.44))
            star3BezierPath.addLine(to: CGPoint(x: 46.13, y: 14.94))
            star3BezierPath.addLine(to: CGPoint(x: 46.68, y: 11.75))
            star3BezierPath.addLine(to: CGPoint(x: 44.36, y: 9.49))
            star3BezierPath.addLine(to: CGPoint(x: 47.57, y: 9.03))
            star3BezierPath.close()
            StyleKit.green.setFill()
            star3BezierPath.fill()


            //// Star2Bezier Drawing
            let star2BezierPath = UIBezierPath()
            star2BezierPath.move(to: CGPoint(x: 34, y: 1.25))
            star2BezierPath.addLine(to: CGPoint(x: 35.98, y: 5.27))
            star2BezierPath.addLine(to: CGPoint(x: 40.42, y: 5.91))
            star2BezierPath.addLine(to: CGPoint(x: 37.21, y: 9.04))
            star2BezierPath.addLine(to: CGPoint(x: 37.97, y: 13.46))
            star2BezierPath.addLine(to: CGPoint(x: 34, y: 11.38))
            star2BezierPath.addLine(to: CGPoint(x: 30.03, y: 13.46))
            star2BezierPath.addLine(to: CGPoint(x: 30.79, y: 9.04))
            star2BezierPath.addLine(to: CGPoint(x: 27.58, y: 5.91))
            star2BezierPath.addLine(to: CGPoint(x: 32.02, y: 5.27))
            star2BezierPath.close()
            StyleKit.green.setFill()
            star2BezierPath.fill()


            //// Star1Bezier Drawing
            let star1BezierPath = UIBezierPath()
            star1BezierPath.move(to: CGPoint(x: 19, y: 6.12))
            star1BezierPath.addLine(to: CGPoint(x: 20.43, y: 9.03))
            star1BezierPath.addLine(to: CGPoint(x: 23.64, y: 9.49))
            star1BezierPath.addLine(to: CGPoint(x: 21.32, y: 11.75))
            star1BezierPath.addLine(to: CGPoint(x: 21.87, y: 14.94))
            star1BezierPath.addLine(to: CGPoint(x: 19, y: 13.44))
            star1BezierPath.addLine(to: CGPoint(x: 16.13, y: 14.94))
            star1BezierPath.addLine(to: CGPoint(x: 16.68, y: 11.75))
            star1BezierPath.addLine(to: CGPoint(x: 14.36, y: 9.49))
            star1BezierPath.addLine(to: CGPoint(x: 17.57, y: 9.03))
            star1BezierPath.close()
            StyleKit.green.setFill()
            star1BezierPath.fill()


        }
        
        context.restoreGState()

    }

    //// Generated Images

    public dynamic class func imageOfGoal(goalProgress: CGFloat = 1) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 68, height: 88), false, 0)
            StyleKit.drawGoal(goalProgress: goalProgress)

        let imageOfGoal = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfGoal
    }




    @objc public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
